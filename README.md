# Moderator Panel: FastTrack Edition

## Обзор проекта

Это панель модератора, разработанная для эффективной и быстрой проверки объявлений. Проект предоставляет инструменты для фильтрации, сортировки, просмотра детальной информации об объявлениях, а также для принятия решений (одобрение, отклонение, запрос изменений) и отслеживания ключевых метрик модерации.

## Технологический стек

Проект разработан с использованием современного стека:

- **Язык:** **TypeScript**
- **Фреймворк:** **React v18+**
- **Стили:** **Tailwind CSS**
- **Роутинг:** **React Router v6**
- **Управление данными (State Management):** **TanStack Query (React Query)**
- **HTTP-клиент:** **Axios**
- **Графики:** **Recharts**

---

## Инструкция по запуску

### 1\. Клонирование репозитория

```bash
git clone https://github.com/x1lefg0r/Moderator-Panel.git
cd [proj_folder]
```

### 2\. Установка зависимостей

```bash
npm install
npm install recharts
```

### 3\. Запуск Mock API

Проект предполагает работу с API. Убедитесь, что ваш мок-сервер (или бэкенд) запущен на порту, указанном в конфигурации (например, `vite.config.js` или прокси).

### 4\. Запуск приложения

```bash
npm run dev
```

---

## Обоснование выбора ключевых библиотек

Я выбрал специализированные библиотеки, чтобы решить общие проблемы фронтенда наиболее эффективным образом:

### 1\. TanStack Query (React Query)

TanStack Query был выбран как **замена традиционному глобальному стейт-менеджменту**.

- **Фокус на серверный стейт:** Эта библиотека идеально подходит для работы с асинхронными данными (запросами к API), которые составляют 90% состояния модераторской панели.
- **Автоматизация:** Обработка **кеширования**, **инвалидации** (обновление данных после мутаций), **повторных запросов** при потере фокуса окна и **состояний загрузки** (`isLoading`, `isError`) берется на себя.
- **Производительность:** Благодаря кэшированию TanStack Query обеспечивает высокую скорость переключения между страницами (`/list` -\> `/item/:id` -\> `/list`), так как данные не перезагружаются каждый раз.

### 2\. TypeScript

**TypeScript** был выбран для обеспечения надежности, особенно в критически важных областях модерации:

- **Типизация API:** Обеспечивает, что структуры данных, приходящих с сервера (например, `Advertisement`, `StatsSummary`), всегда соответствуют ожидаемым интерфейсам.
- **Сложные типы:** Позволяет строго типизировать сложные структуры, такие как **фильтры** (`FilterState`), **статусы** (`AdStatus`), а также корректно работать с параметрами роутера (`useParams`).

### 3\. Axios (HTTP-клиент)

Был выбран вместо нативного `fetch` благодаря более удобному API:

- **Автоматическая обработка JSON:** Не требуется ручное `.json()`.
- **Настройка:** Легко настраивать базовый URL (`baseURL: "api/v1"`), что упрощает настройку прокси.

### 4\. Recharts (Графики)

Recharts выбран для страницы статистики (`/stats`) как **легковесная, компонуемая** библиотека:

- **React-нативный:** Компоненты Recharts (такие как `<BarChart>`, `<PieChart>`) легко интегрируются в React-компоненты, позволяя использовать хуки (`useQuery`) для управления их данными.
- **Адаптивность:** Компонент `<ResponsiveContainer>` позволяет легко создавать адаптивные графики, которые корректно масштабируются в Tailwind-контейнерах.

### 5\. Tailwind CSS

- **Скорость разработки:** Позволяет очень быстро верстать сложный UI (фильтры, карточки, модальные окна, статистику) прямо в JSX-файлах без переключения контекста.
- **Дизайн:** Обеспечивает чистый, современный вид, идеально подходящий для профессиональной панели управления.

---

## Ключевые архитектурные решения

### 1\. Управление фильтрами в URL

- **Хук `useAdsFilters`:** Вся логика фильтрации, сортировки и поиска инкапсулирована в один хук.
- **Source of Truth (Единственный источник истины):** Состояние фильтров хранится **в URL-адресе** (`?status=pending&page=1&sort=date_desc`), а не во внутреннем состоянии компонента. Это обеспечивает:
  - **"Шаринг" состояния:** Модератор может поделиться ссылкой, и получатель увидит ту же выборку.
  - **Навигация:** Кнопки "Назад/Вперед" в браузере работают с фильтрами по умолчанию.

### 2\. Умная межстраничная навигация

- **Проблема:** При листании объявлений на странице `/item/:id` стандартный переход `Maps(-1)` возвращает на предыдущее объявление, а не в список, создавая петлю.

- **Решение:** При переходе из `/list` в `/item/:id` через **`react-router-dom` State** передается **контекст**:

  - **`from`**: Строка URL-фильтров (`?status=pending&page=2`). Кнопка "Назад к списку" использует этот параметр для возврата к точному состоянию списка.
  - **`listIds`**: Массив ID текущей страницы. Это позволяет реализовать навигацию "Следующее/Предыдущее" **в пределах текущей выборки**.

- **Листание сквозь пагинацию:** На странице `/item/:id`, если пользователь доходит до последнего элемента в `listIds`, приложение **самостоятельно запрашивает следующую страницу** списка (`fetchAds({ page: currentPage + 1 })`), чтобы получить ID первого элемента и продолжить бесшовное листание.

### 3\. Модульность

Код API был разнесен на отдельные файлы (`ads.ts`, `stats.ts`), а логика модерации (мутации) и отображения (графики) изолированы в соответствующие компоненты, что обеспечивает чистоту и легкую тестируемость.

---

## Признание

Я прекрасно понимаю, что считалось бы хорошей практикой разбить страницы на гораздо больше мелких, атомарных компонентов (например, отдельный компонент `FilterDropdown`, `PaginationButtons`, вынесение отдеьных утилит - в общем тут реально я обалдуй).

Сделал я так, поскольку боялся не **уложиться в сроки** и просто напросто не успеть предоставить работающий функционал(даже с выполненными заданиями со здездочкой, между прочим!!). Прошу "казнить нельзя, помиловать" за эту такую архитектуру.
